# **************************************************************************
# *                                                                        *
# *   Copyright (c) 2023 Keith Sloan <keith@sloan-home.co.uk>              *
# *                      Munther Hindi                                      *
# *                                                                        *
# *   This program is free software; you can redistribute it and/or modify *
# *   it under the terms of the GNU Lesser General Public License (LGPL)   *
# *   as published by the Free Software Foundation; either version 2 of    *
# *   the License, or (at your option) any later version.                  *
# *   for detail see the LICENCE text file.                                *
# *                                                                        *
# *   This program is distributed in the hope that it will be useful,      *
# *   but WITHOUT ANY WARRANTY; without even the implied warranty of       *
# *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        *
# *   GNU Library General Public License for more details.                 *
# *                                                                        *
# *   You should have received a copy of the GNU Library General Public    *
# *   License along with this program; if not, write to the Free Software  *
# *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 *
# *   USA                                                                  *
# *                                                                        *
# *   Acknowledgements :                                                   *
#
#	Thanks to FreeCAD forum members
#
#		TheMarkster
#                                                                          *
#     Takes as input a GDML file directory and creates/updates             *
#          STEP / BREP files from the GDML definitions                     *
#                                                                          *
#             python3 processDirStruct.py <directory>                      *
#                                                                          *
#***************************************************************************
import sys, os
import math

class volAsm_class:
 	# ??? volasm in several places aslo different levels?
	def __init__(self, vaName, path, level):
		print(f"New volasm {vaName} path {path} level {level}")
		self.vaName = vaName
		self.path = path
		self.subVolAsmList = []
		self.level = level


	def getName(self):
		return self.vaName


	def getLevel(self):
		return self.level


	def addSubVolAsms(self, volasmList):
		self.subVolAsmList = volasmList


	def getSubVolAsms(self):
		return self.subVolAsmList


	def printSubVolAsms(self):
		print(f"Volume {self.vaName}")
		for i in self.subVolAsmList:
			print(i.getName())    


	def processPath(self, path, level, levels, volAsmDict):
		print(f"Processing path {path} level {level}")
		vaName = os.path.splitext(os.path.basename(path))[0]
		print(f"Processing VolAsm {vaName} Level {level}")
		volAsm = volAsm_class(vaName, path, level)
		#volAsm = volAsm_class(vaName, path)
		# Add volume to dictionary
		volAsmDict[self.vaName] = vaName
		#print(f"new Volume {volAsm.getName()}")
		levels.addVolAsm(volAsm, self.path, level)
		subVolAsms = os.scandir(path)
		for p in subVolAsms:
			if p.is_dir():
				self.processPath(p.path, level+1, levels, volAsmDict)

	def join(self, path, name):
		import os
		return(os.path.join(path, name))


	def printList(self, name, objList, msg=""):
		print(f"List ===== {name} ===== {msg}")
		#print(dir(objList))
		for o in objList:
			print(f" {o.Name} : {o}")
		print("===================")


	def printTupleList(self, name, objList, msg=""):
	        print(f"List ===== {name} ===== {msg}")
	        # print(dir(objList))
	        for o in objList:
	            print(f"Level {o[0]} : {o[1].Name}")
	        print("===================")


	def sortObjList(self, inputList):
		testList = sorted(inputList, key=lambda x: x.Volume, reverse=True)
		for o in testList:
			print(f"Item {o} : {o.Volume}")
		return testList

	def objSortedShapesOnly(self, obj):
		saveList =[]
		for o in obj.OutList:
			if hasattr(o, "Shape"):
				saveList += [o]
		self.printList("SaveList", saveList)
		testList = sorted(saveList, key=lambda x: x.Shape.BoundBox.DiagonalLength, reverse=True)
		for o in testList:
			print(f"{o.Name} : {o.Shape.BoundBox.DiagonalLength}")
		return testList

	def countGDMLObj(self, subVols, obj):
		gdmlCnt = 0
		if hasattr(obj, "OutList"):
			for o in obj.OutList:
				if hasattr(o, "Proxy"):
					if hasattr(o.Proxy, "Type"):
						if o.Proxy.Type[0:4] == "GDML":
							gdmlCnt += 1
				if o.TypeId == "App::Part":
					s, g = self.countGDMLObj(subVols, o)
					subVols += s +1
		print(f"SubVols {subVols} gdmlCnt {gdmlCnt}")
		return subVols, gdmlCnt


	def exportStep(self, obj):
		# Step export uses Import
		import Import
		exportPath = self.join(self.path, self.vaName+".step")
		print(f"export Path {exportPath}")
		if hasattr(Import, "exportOptions"):        
			options = Import.exportOptions(exportPath)
			Import.export(obj, exportPath, options)
			print(f"exported {obj.Name} type {typeId} wih Options")
		else:
			Import.export([obj], exportPath)
			print(f"Step exported {obj.Name} ")


	def exportBrep(self, obj):
		# Brep export uses Part:
		import Part
		exportPath = self.join(self.path, self.vaName+".brep")
		print(f"export Path {exportPath}")
		if hasattr(Part, "exportOptions"):        
			options = Part.exportOptions(exportPath)
			Part.export(obj, exportPath, options)
			print(f"exported {obj.Name} type {typeId} wih Options")
		else:
			Part.export([obj], exportPath)
			print(f"Brep exported {obj.Name}")


	def exportBrepShell(self, obj):
		# Brep export uses Part:
		import Part
		exportPath = self.join(self.path, self.vaName+"_Shell.brep")
		print(f"export Path {exportPath}")
		if hasattr(Part, "exportOptions"):        
			options = Part.exportOptions(exportPath)
			Part.export(obj, exportPath, options)
			print(f"exported {obj.Name} type {typeId} wih Options")
		else:
			Part.export([obj], exportPath)
		print(f"Brep exported {obj.Name}")


	def checkBoundBoxes(self, shape1, shape2, tolerance):
		for i in range(4):
			if shape1.BoundBox.isInside(shape2.BoundBox.getPoint(i), tolerance)  is False:
				return False
		return True


	def checkNotInside(self, item1, item2, tolerance=Part.Precision.confusion()):
		global shapeNames
		shp1 = item1
		shp2 = item2
		print(f"Testing if {shapeNames[shp2]} isNotInside {shapeNames[shp1]}")
		commonShape = shp1.common(shp2)
		print(f"Shape1 Volume {shp1.Volume}  Shape2 Volume {shp2.Volume} commonShape Volume {commonShape.Volume}")

		if math.isclose(commonShape.Volume, shp2.Volume, abs_tol=tolerance):
			print("Return Not Inside False")
			return False
		print("Return Not Inside True")
		return True


	def getObjectList(self, lvl, obj):
		# Now Level only used for avoiding WorldBox
		print(f">>>>>  Get Object List {obj.Name}  level {lvl} <<<<<")
		lst = []
		if hasattr(obj, "OutList"):
			print(obj.OutList)
			self.printList("OutList", obj.OutList )
			for o in obj.OutList:
				print(f"{o.Name} TypeId {o.TypeId}")
				if o.TypeId == "App::Part" or o.TypeId == "App::Link":
					subItem = self.getObjectList(lvl+1, o)
					lst += subItem
				elif hasattr(o, "Proxy"):
					print("Proxy")
					if hasattr(o.Proxy, "Type"):
						print(f"Type {o.Proxy.Type}")
						if o.Proxy.Type[0:4] == "GDML":
							if lvl > 0:	# lvl 0 World GDML Object
								lst.append((lvl, o))
		# print(f"Returning {(lvl, lst)}")
		print(f"Returning {lst}")
		self.printTupleList("Tuple List", lst)
		# return (lvl, lst)
		return lst


	def exportBrepStep(self):
		print(f"Export STEP & Brep {self.vaName} path {self.path}")
		name = self.vaName+".gdml"
		#path = "u"+ self.join(self.path, name)
		path = self.join(self.path, name)
     
		import freecad.gdml.importGDML
		#freecad.gdml.importGDML.open(u"/Users/keithsloan/Downloads/CERN-Dipole/Dipole/DCoil/DL0/DL1/DL1.gdml")
	
		freecad.gdml.importGDML.open(path, processType = 1, prompt=False)
		doc = FreeCAD.ActiveDocument
		print(f"GDML file opened {path} Root Volume {self.vaName}")
		obj = doc.getObject(self.vaName)
		doc.recompute()
		# If problem with name i,e has underscore etc
		if obj is None:
			obj = doc.RootObjects[-1]
			print(f"Root Vol {self.vaName} type {obj.TypeId}")
		# Make Compound and save Brep
		print(f"obj {obj.Name}")
		#print(f"obj {obj.Name} OutList {obj.OutList}"
		# Create List that have Shapes)
		saveList =[]
		for o in obj.OutList:
			if hasattr(o, "Shape"):
				saveList += [o]
		print(f" SaveList :{saveList}")
		cmpLinks = []
		testList = sorted(saveList, key=lambda x: x.Shape.BoundBox.DiagonalLength, reverse=True)
		print(f"  TestList sorted by size, largest to smallist")
		for o in testList:
			print(f"{o.Name} : {o.Shape.BoundBox.DiagonalLength}")
		#for i, o in enumerate(saveList):
		for o in saveList:
			if hasattr(o,"Shape"):
				print(f"Testing if {o.Name} with list {testList}")
				if self.checkNotInside(o, testList):
					print(f"Append {o.Name}")
					cmpLinks +=[o]
				else:
					print(f"Remove {o.Name}")
					testList.remove(o)	
		if len(cmpLinks) > 0 :
			cmp = obj.newObject("Part::Compound","Compound")
			cmp.Links = cmpLinks		
			print(f"Compound Links {cmp.Links}")
			print("Recompute")
			doc.recompute()
			#asm.recompute()
			print(f"Compound Created")
			self.exportBrepShell(cmp)
		else:
			print(f"No BrepShe; created")
		#FreeCAD.closeDocument(doc.Name)

	def getGlobalPlacementFunction(self, obj):
		if hasattr(obj,"Parents"):
			rootParent = obj.Parents[0]
			for paren, path in obj.Parents:
				sub = paren.getSubObject(path)
				globalPlace = obj.Placement * sub.Placement
			print(f'Using Sub {paren.FullName}.{path}  {globalPlace}')
		else:
			globalPlace = obj.getGlobalPlacement()
			print(f'Direct {obj.FullName} {globalPlace}')

		return globalPlace

		print(f'Direct links to {obj.Name}')
		directlinks =[link for link in doc.findObjects(Type = 'App::Link') if link.LinkedObject.Name == obj.Name] 

		for link in directlinks:
			if link.Parents:
				for parent, path in link.Parents:
					sub = parent.getSubObject(path)
					globalPlace = sub.Placement
					print(f'{parent.FullName}.{path}{globalPlace}')
			else:
				globalPlace = link.Placement
				print(f'{link.FullName} {globalPlace}')
		return globalPlace


	def processGDMLfile(self):
		# Needs FreeCAD 0.22 or later
		print(f"UtilsAssembly - need FreeCAD 0.22 or later")
		import UtilsAssembly
		global shapeNames
		shapeNames = {}
		print(f"Export Brep Shell path {self.path}")
		name = self.vaName+".gdml"
		#path = "u"+ self.join(self.path, name)
		self.fullPath = self.join(self.path, name)     

		import freecad.gdml.importGDML
		#freecad.gdml.importGDML.open(u"/Users/keithsloan/Downloads/CERN-Dipole/Dipole/DCoil/DL0/DL1/DL1.gdml")
		# processType = 4  - Look for saved brepShell file.
		freecad.gdml.importGDML.open(self.fullPath, processType = 4, prompt=False)
		doc = FreeCAD.ActiveDocument
		print(f"GDML file opened {self.fullPath} Root Volume {self.vaName}")
		obj = doc.RootObjects[-1]
		print(f"Root Vol {obj.Name} type {obj.TypeId}")
		subVols, gdmlCnt = self.countGDMLObj(0, obj)
		if subVols > 1 and gdmlCnt == 1:
			# Remove any world gdml Object
			inputList = self.getObjectList(0, obj)
		else:
			inputList = self.getObjectList(1, obj)
		self.printTupleList("inputList", inputList)
		shapes = []
		for t in inputList:
			#s = Part.getShape(t[1], mat=t[1].getGlobalPlacement().Matrix, transform=False)
                          o = t[1]
                          gpMat = UtilsAssembly.getGlobalPlacement(o).Matrix
                          s = Part.getShape(o, mat=gpMat, transform=False) 
                          shapeNames[s] = o.Name
                          shapes.append(s)
		testList = self.sortObjList(shapes)
		insideSomething = {}
		insideSomething[testList[0]] = False
		for i, o in enumerate(testList[:-1]):
			for t in testList[i+1:]:
				if self.checkNotInside(o, t) is True:
					if t in insideSomething:
						insideSomething[t] |= False
					else:
						insideSomething[t] = False
				else:
					if t in insideSomething:
						insideSomething[t] |= True
					else:
						insideSomething[t] = True
		shape = shapes[0]
		for t in insideSomething:
			if insideSomething[t] is False:
				print(f"fusing {shapeNames[t]}")
				shape = shape.fuse(t)
				print(f"Current Volume {shape.Volume}")
		print(f"Volume {shape.Volume}")
		o = Part.show(shape)
		#cmp = obj.newObject("App::Part", "Outside")
		#cmp.addObject(o)
		#cmp.Shape = shape
		doc.recompute()
 		# asm.recompute()
		print("Shape created")    
		#print("Compound Shape Created")
		self.exportBrepShell(o)
		#FreeCAD.closeDocument(doc.Name)
        
class levelDet:
	def __init__(self):
		self.volAsmList = []


	def getNumVolAsm(self):
		return len(self.volAsmList)


	def getVolAsms(self):
		return self.volAsmList


	def levelAddVolAsm(self, volAsm, path, level):
		print(f"Add Volume {volAsm.getName()} to level_i {level} level {volAsm.getLevel()}")
		#self.volAsmList.append(volAsm_class(vaName, path, level))    
		self.volAsmList.append(volAsm)   


class levels_class:
	def __init__(self):
		self.levels = []


	def addLevel(self):
 		#print(f"levels add level")
		self.levels.append(levelDet())
		#print(f"len self.levels {len(self.levels)}")


	def checkLevel(self, lvlNum):
		#print(f"levels checkLevel lvlNum {lvlNum} levels {len(self.levels)}")
		#print(f"test {lvlNum > len(self.levels)}")
		# Lists index from 0
		lvl = int(lvlNum) - 1
		if lvlNum > len(self.levels):
			self.addLevel()
		#else:
		#    print("No need to add")    
		return self.levels[lvl]


	def addVolAsm(self, volAsm, path, lvlNum):
		#print(f"levels add VolAsm {volAsm.getName()}")
		levelDet = self.checkLevel(lvlNum)
		levelDet.levelAddVolAsm(volAsm, path, lvlNum)


	def print(self):
		# print(f"Levels {self.levels}")
		for i, l in enumerate(self.levels):
			print(f" Level {i} Number of VolAsm {l.getNumVolAsm()}")

	def process(self):
		self.numVolAsm = 3
		# print(f"Levels {self.levels}")
		print(f"\nListing levels in Reverse order\n")
		for i, l in reversed(list(enumerate(self.levels))):
			numVolAsm = l.getNumVolAsm()
			print(f" >>>>>>> Listing Level {i} Number of VolAsm {numVolAsm}")
		print(f"\nProcessing levels in Reverse order\n")
		for i, l in reversed(list(enumerate(self.levels))):
			volAsmList = l.getVolAsms()
			print(f"Level {i}")
			for volAsm in volAsmList:
				print(f">>>>> Process volAsm {volAsm.getName()} Level_i {i} Level {volAsm.getLevel()}")
				volAsm.processGDMLfile()
           

class dirBase_class:
	def __init__(self):
		from PySide2 import QtGui, QtCore, QtWidgets
		self.volAsmDict = {}
		self.levels = levels_class()
		self.basePath = QtWidgets.QFileDialog.getExistingDirectory(None, "Select Directory")
		print(f"\nProcessing GDML directory : {self.basePath}")
		vaName = os.path.splitext(os.path.basename(self.basePath))[0]

		self.baseVolAsm = volAsm_class(vaName, self.basePath, 1)
		self.baseVolAsm.processPath(self.basePath, 1, self.levels, self.volAsmDict)

		print(f"Base Path {self.basePath}\n")
		#print(f"Path List \n")
		#for i in self.pathList:
		#    print(i.getName()
		self.baseVolAsm.printSubVolAsms()
		self.levels.print()
		self.levels.process()

		#baseVaName = os.path.splitext(os.path.basename(basePath))[0]
		#evels = levels_class()

base = dirBase_class()
