# **************************************************************************
# *                                                                        *
# *   Copyright (c) 2023 Keith Sloan <keith@sloan-home.co.uk>              *
# *                      Munther Hindi                                      *
# *                                                                        *
# *   This program is free software; you can redistribute it and/or modify *
# *   it under the terms of the GNU Lesser General Public License (LGPL)   *
# *   as published by the Free Software Foundation; either version 2 of    *
# *   the License, or (at your option) any later version.                  *
# *   for detail see the LICENCE text file.                                *
# *                                                                        *
# *   This program is distributed in the hope that it will be useful,      *
# *   but WITHOUT ANY WARRANTY; without even the implied warranty of       *
# *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        *
# *   GNU Library General Public License for more details.                 *
# *                                                                        *
# *   You should have received a copy of the GNU Library General Public    *
# *   License along with this program; if not, write to the Free Software  *
# *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 *
# *   USA                                                                  *
# *                                                                        *
# *   Acknowledgements :                                                   *
#
#	Thanks to FreeCAD forum members
#
#		TheMarkster
#                                                                          *
#     Takes as input a GDML file directory and creates/updates             *
#          STEP / BREP files from the GDML definitions                     *
#                                                                          *
#             python3 processDirStruct.py <directory>                      *
#                                                                          *
#***************************************************************************
import sys, os
import math

class dirBase_class:
	def __init__(self):
		from PySide2 import QtGui, QtCore, QtWidgets
		import glob
		basePath = QtWidgets.QFileDialog.getExistingDirectory(None, "Select Directory")
		print(f"\nProcessing directory for GDML files : {basePath}")
		processPath = os.path.join(basePath,"*.gdml")
		print(f"Process Path {processPath}")
		for fn in glob.glob(processPath):
			self.setPathAndName(fn)
			self.processGDMLfile(fn)


	def setPathAndName(self, path):
		names = os.path.split(path)
		self.path = names[0]		
		self.vaName = names[1]
		print(f"Path : {self.path} : vaName{self.vaName}")


	def join(self, path, name):
		import os
		return(os.path.join(path, name))


	def printList(self, name, objList, msg=""):
		print(f"List ===== {name} ===== {msg}")
		#print(dir(objList))
		for o in objList:
			print(f"{o.Name} {o}")
		print("===================")


	def printTupleList(self, name, objList, msg=""):
		print(f"List ===== {name} ===== {msg}")
		#print(dir(objList))
		for o in objList:
			print(f"Level {o[0]} : {o[1].Name}")
		print("===================")

	def checkBoundBoxes(self, shape1, shape2, tolerance):
		for i in range(4):
			if shape1.BoundBox.isInside(shape2.BoundBox.getPoint(i), tolerance)  == False:
				return False
		return True

	def checkNotInside(self, lvl1, obj1, lvl2, obj2, tolerance=Part.Precision.confusion()):
		# Don't test with self.
		if obj1 != obj2:
			# Check boundingbox is same level
			if lvl1 == lvl2:
				# BoundingBox's may be inside but that does not mean Shape is inside
				# Checking BoundingBox as a way of weeding out cases where Not Inside 
				print(f"BoundBox : {obj1.Name} : {obj1.Shape.BoundBox} : {obj1.Name} : {obj2.Shape.BoundBox} {not obj2.Shape.BoundBox.isInside(obj1.Shape.BoundBox)}")
				#if not obj.Shape.BoundBox.isInside(o.Shape.BoundBox): 
				if not obj2.Shape.BoundBox.isInside(obj1.Shape.BoundBox):
					return True
			# Having eliminating Shapes with Bounding boxes NOT inside - do further checks
			cutShape = obj1.Shape.cut(obj2.Shape)
			#print(dir(cutShape))
			cutVol = obj1.Shape.Volume - obj2.Shape.Volume
			print(f"Obj1 Volume {obj1.Shape.Volume}  Obj2 Violume {obj2.Shape.Volume} CutShape Volume {cutShape.Volume} Vol Diff  {cutVol}")
			if math.isclose(cutVol, cutShape.Volume, abs_tol = tolerance):
				print(f"Return False")
				return False
		return True


	def exportBrep(self, obj):
		# Brep export uses Part:
		import Part
		exportPath = self.join(self.path, self.vaName+".brep")
		print(f"export Path {exportPath}")
		if hasattr(Part, "exportOptions"):        
			options = Part.exportOptions(exportPath)
			Part.export(obj, exportPath, options)
			print(f"exported {obj.Name} type {typeId} wih Options")
		else:
			Part.export([obj], exportPath)
			print(f"Brep exported {obj.Name}")


	def exportBrepShell(self, obj):
		# Brep export uses Part:
		import Part
		exportPath = self.join(self.path, self.vaName+"_Shell.brep")
		print(f"export Path {exportPath}")
		if hasattr(Part, "exportOptions"):        
			options = Part.exportOptions(exportPath)
			Part.export(obj, exportPath, options)
			print(f"exported {obj.Name} type {typeId} wih Options")
		else:
			Part.export([obj], exportPath)
			print(f"Brep exported {obj.Name}")

	def objSortedShapesOnly(self, obj):
		saveList =[]
		for o in obj.OutList:
			if hasattr(o, "Shape"):
				saveList += [o]
		self.printList("SaveList", saveList)
		testList = sorted(saveList, key=lambda x: x.Shape.BoundBox.DiagonalLength, reverse=True)
		for o in testList:
			print(f"{o.Name} : {o.Shape.BoundBox.DiagonalLength}")
		return testList


	def sortObjList(self, inputList):
		testList = sorted(inputList, key=lambda x: x[1].Shape.BoundBox.DiagonalLength, reverse=True)
		for o in testList:
			print(f"Item {o[0]} {o[1].Name} : {o[1].Shape.BoundBox.DiagonalLength}")
		return testList


	def getObjectList(self, lvl, obj):
		print(f">>>>>  Get Object List {obj.Name}  level {lvl} <<<<<")
		lst = []
		if hasattr(obj, "OutList"):
			#self.printList("OutList", obj.OutList )
			for o in obj.OutList:
				#print(f"{o.Name}")
				if o.TypeId == "App::Part":
					subItem = self.getObjectList(lvl+1, o)
					lst += subItem
				elif hasattr(o, "Proxy"):
					print(f"Proxy")
					if hasattr(o.Proxy, "Type"):
						print(f"Type {o.Proxy.Type}")
						if o.Proxy.Type[0:4] == "GDML":
							if lvl > 0:
								lst.append((lvl,o))
		#print(f"Returning {(lvl, lst)}")
		print(f"Returning {lst}")
		self.printTupleList("Tuple List",lst)
		#return (lvl, lst)
		return lst
				
				
	def countGDMLObj(self, obj):
		print(f"Count GDML Obj")
		gdmlCnt = 0
		subVol = []
		if hasattr(obj, "OutList"):
			for o in obj.OutList:
				if hasattr(o, "Proxy"):
					if hasattr(o.Proxy, "Type"):
						if o.Proxy.Type[0:4] == "GDML":
							gdmlCnt += 1
				if o.TypeId == "App::Part":
					subVol += [o]
		print(f"SubVol {subVol} gdmlCnt {gdmlCnt}")
		return subVol, gdmlCnt


	def processGDMLfile(self, path):
		print(f"Export STEP & Brep path {path}")
     
		import freecad.gdml.importGDML
		#freecad.gdml.importGDML.open(u"/Users/keithsloan/Downloads/CERN-Dipole/Dipole/DCoil/DL0/DL1/DL1.gdml")
	
		freecad.gdml.importGDML.open(path, processType = 2, prompt=False)
		doc = FreeCAD.ActiveDocument
		print(f"GDML file opened GDML file {path}")
		obj = doc.RootObjects[-1]
		print(f"Root Vol {obj.Name} type {obj.TypeId}")
		subVol, gdmlCnt = self.countGDMLObj(obj)
		lnSubVol = len(subVol)
		#if lnSubVol == 1 :
		#	print(f"World Volume - skip World Object")
		#	obj = subVol[0]
		#	subVol, gdmlCnt = self.countGDMLObj(obj)
		#
		#if lnSubVol > 1 and gdmlCnt == 1:
		#	print(f"Omit World BoundBox")
		#	testList = testList[1:]
		# Create List that have Shapes)
		inputList = self.getObjectList(0, obj)
		return
		print(f"inputList {inputList}")
		self.printList("inputList", inputList)
		testList = self.sortObjList(inputList)
		cmpLinks = [testList[0]]
		rmvList = []
		#print(f"cmpLinks {cmpLinks}")
		self.printList("cmpLinks", cmpLinks, "Compound Links")
		for o in testList:
			for t in testList[1:]:
				if o != t:
					#self.printList("RmvList", rmvList)
					if t not in rmvList:
						print(f"Testing if {t.Name} isNotInside {o.Name}")
						#print(f"Check if NOT inside {self.checkNotInside(o, t)}")
						if self.checkNotInside(o[0], o[1], t[0], t[1]) == True:
							if t not in cmpLinks:
								print(f"Append {t.Name}")
								cmpLinks += [t]
							else:
								print("Already appended")
						else:
							print(f"Remove {t.Name}")
							rmvList += [t]
		print(f"cmpLinks {cmpLinks}")	
		if len(cmpLinks) > 0 :
			cmp = obj.newObject("Part::Compound","Compound")
			cmp.Links = cmpLinks		
			self.printList("cmpLinks", cmp.Links, "Compound Links")
			doc.recompute()
			#asm.recompute()
			print(f"Compound Created")
			self.exportBrepShell(cmp)
		else:
			print(f"No BrepShape; created")
		FreeCAD.closeDocument(doc.Name)


base = dirBase_class()
